name: Cargo Cache
description: Cache cargo build files and the registry
inputs:
  cache-group:
    description: |
      The group of the cache, defaults to the job ID.
      If you want two jobs to share the same cache, give them the same group name.
    required: false
    default: ${{ github.job }}
  cargo-home:
    description: |
      The location of the Cargo cache files.
      If you specify the `CARGO_HOME` env variable for your commands, you need to set it here too.
      This must NOT end with the trailing slash of the directory.
      Defaults to `~/.cargo`.
    required: false
    default: ~/.cargo
  cargo-target-dir:
    description: |
      Location of where to place all generated artifacts, relative to the current working directory. 
      If you specify the `CARGO_TARGET_DIR` env variable for your commands, you need to set it here too.
      This must NOT end with the trailing slash of the directory.
      Defaults to `target`.
    required: false
    default: target
  save-always:
    description: |
      Run the post step to save the cache even if another step before fails.
      Defaults to `true`.
    required: false
    default: true
outputs:
  cache-hit:
    description: |
      A boolean value to indicate if an exact match was found for the key.
      Passed through from the `actions/cache` action.
    value: ${{ steps.cache.outputs.random-number }}
runs:
  using: composite
  steps:
    # The `Cargo.lock` file contains the exact crates used as dependencies.
    # It is important to use for the caching key, because it might become outdated otherwise.
    # If only the `Cargo.toml` file was used, patch releases of crates could cause unnecessary re-compiles.
    # Therefore, if the `Cargo.lock` file does not yet exist (e.g. for libraries), we need to create it first.
    # If the `Cargo.lock` file has been committed to the repo we reuse it to reproduce the same scenario.
    - name: Create Cargo.lock file
      shell: bash
      run: |
        if [ -f "Cargo.lock" ]; then
            echo "Reusing already existing Cargo.lock file."
        else 
            echo "Cargo.lock file does not exist, creating it..."

            # Check if cargo is installed
            cargo --version

            if [ $? -eq 0 ]; then
                # Create Cargo.lock file
                cargo update
                exit $?
            else
                echo "Cargo is not installed!" >&2
                echo "  help: Try using the 'dtolnay/rust-toolchain@master' action before this one." >&2
                exit 1
            fi
        fi

    # The dependencies are recompiled if a new Rust version is used
    # This steps determines the Cargo version to include it in the cache key
    - name: Get cargo version
      id: cargo-version
      shell: bash
      run: |
        # Print version once for debugging
        cargo --version

        # Extract the commit hash and date of the cargo version
        # E.g. "cargo 1.72.0-nightly (0c14026aa 2023-06-14)" becomes "(0c14026aa 2023-06-14)"
        version=$(cargo --version | grep -oE "\(([a-z0-9]+) [0-9-]+\)")

        # Write the extracted version to a GitHub output variable
        # See <https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#outputs-for-composite-actions>
        echo "cargo-version=$(echo $version)" >> "${GITHUB_OUTPUT}"

    # The workflow file specifies the cargo command that will be run.
    # If the cargo command changes, the previous cache will be outdated.
    - name: Get workflow path
      id: workflow-path
      shell: bash
      run: |
          WORKFLOW_REF='${{ github.workflow_ref }}'
          
          # Strip git ref suffix
          WORKFLOW_ABS_PATH="${WORKFLOW_REF%%@*}"
          # Strip repository prefix
          WORKFLOW_PATH="${WORKFLOW_ABS_PATH#'${{ github.repository }}/'}"
          
          echo "WORKFLOW_PATH=${WORKFLOW_PATH}" >> "${GITHUB_ENV}"

    # See <https://github.com/actions/cache>.
    - name: Create cache
      id: cache
      uses: actions/cache@v4
      with:
        save-always: ${{ inputs.save-always }}
        path: |
          ${{ inputs.cargo-home }}/bin/
          ${{ inputs.cargo-home }}/registry/index/
          ${{ inputs.cargo-home }}/registry/cache/
          ${{ inputs.cargo-home }}/git/db/
          ${{ inputs.cargo-target-dir }}/
        # Don't share a cache between different values of the following:
        # - `cache-group`     (user-defined)
        # - `runner.os`       (build platform)
        # Reset the cache any time one of the following changes:
        # - `cargo --version` (build toolchain)
        # - Workflow file     (build commands)
        # Restore from a fallback cache any time one of the following changes:
        # - `Cargo.toml` file (build configs)
        # - `Cargo.lock` file (build dependencies)
        key: ${{ inputs.cache-group }}-${{ runner.os }}-${{ steps.cargo-version.outputs.cargo-version }}-${{ hashFiles(env.WORKFLOW_PATH) }}-${{ hashFiles('**/Cargo.toml') }}-${{ hashFiles('**/Cargo.lock') }}
        # Restore caches from the same group.
        restore-keys: |
          ${{ inputs.cache-group }}-${{ runner.os }}-${{ steps.cargo-version.outputs.cargo-version }}-${{ hashFiles(env.WORKFLOW_PATH) }}-${{ hashFiles('**/Cargo.toml') }}-
          ${{ inputs.cache-group }}-${{ runner.os }}-${{ steps.cargo-version.outputs.cargo-version }}-${{ hashFiles(env.WORKFLOW_PATH) }}-
